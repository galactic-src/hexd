<html>
<head>

<script>

const SQRT3 = Math.sqrt(3);
const rounded = (scalar) => Math.round(scalar*100)/100;

const calcHexHeight = (edgeLength) => edgeLength * 2;
const calcHexWidth = (edgeLength) => edgeLength * SQRT3;

const getEdgeLength = () => document.getElementById('edge').value * 1;
const setEdgeLength = (edgeLength) => document.getElementById('edge').value = rounded(edgeLength);
const getCanvasContext = () => document.getElementById('output').getContext("2d");
const getCanvasHeight = () => document.getElementById('output').height * 1;
const getCanvasWidth = () => document.getElementById('output').width * 1;
const getXOffset = () => document.getElementById('x').value * 1;
const setXOffset = (xOffset) => document.getElementById('x').value = rounded(xOffset);
const getYOffset = () => document.getElementById('y').value * 1;
const setYOffset = (yOffset) => document.getElementById('y').value = rounded(yOffset);
const getImage = () => document.getElementById('hiddenImage');

function onXChanged(newXOffset) {
  const canvasWidth = getCanvasWidth();
  const edgeLength = getEdgeLength();
  const hexWidth = calcHexWidth(edgeLength);

  if (newXOffset < 0) {
    newXOffset = 0;
  } else if (newXOffset > canvasWidth) {
    newXOffset = canvasWidth;
  }

  const newHexLeft = newXOffset - hexWidth / 2;
  const newHexRight = newXOffset + hexWidth / 2; 

  if (newHexLeft < 0) {
    setEdgeLength(newXOffset / (SQRT3/2));
  } else if (newHexRight > canvasWidth) {
    setEdgeLength((canvasWidth - newXOffset) / (SQRT3/2));
  }

  redraw();
}

function onYChanged(newYOffset) {
  const canvasHeight = getCanvasHeight();
  const edgeLength = getEdgeLength();
  const hexHeight = calcHexHeight(edgeLength);
  
  if (newYOffset < 0) {
    newYOffset = 0;
  } else if (newYOffset > canvasHeight) {
    newYOffset = canvasHeight;
  }

  const newHexTop = newYOffset - hexHeight / 2;
  const newHexBottom = newYOffset + hexHeight / 2;

  if (newHexTop < 0) {
    setEdgeLength(newYOffset);
  } else if (newHexBottom > canvasHeight) {
    setEdgeLength(canvasHeight - newYOffset);
  }

  redraw();
}

function onEdgeChanged(newEdge) {
  const canvasHeight = getCanvasHeight();
  const canvasWidth = getCanvasWidth();

  let cappedEdge = newEdge;
  if (calcHexHeight(newEdge) > canvasHeight) {
    cappedEdge = canvasHeight/2;
  }

  if (calcHexWidth(cappedEdge) > canvasWidth) {
    cappedEdge = canvasWidth/SQRT3;
  }

  if (cappedEdge !== newEdge) {
    setEdgeLength(cappedEdge);
  }

  const xOffset = getXOffset();
  const hexWidth = calcHexWidth(cappedEdge);
  if (xOffset + hexWidth / 2 > canvasWidth) {
    setXOffset(canvasWidth - hexWidth / 2);
  } else if (xOffset - hexWidth / 2 < 0) {
    setXOffset(hexWidth / 2);
  }

  const yOffset = getYOffset();
  const hexHeight = calcHexHeight(cappedEdge);
  if (yOffset + hexHeight / 2 > canvasHeight) {
    setYOffset(canvasHeight - hexHeight / 2);
  } else if (yOffset - hexHeight / 2 < 0) {
    setYOffset(hexHeight / 2)
  }

  redraw();
}

function redraw() {
  const ctx = getCanvasContext();
  if (getEdgeLength() === 0) {
    clear(ctx);
  } else {
    copyImageToCanvas(ctx);
    cropHex(ctx);
    //drawHexOutline(ctx);
  }
}

function clear(ctx) {
  resetCtx(ctx);
  ctx.globalCompositeOperation = 'destination-out';
  ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
}

function onFileSelected(evt) {
  const selectedFile = event.target.files[0];
  if (selectedFile === undefined) {
    return;
  }

  const oldImg = getImage();
  if (oldImg !== null) {
    document.body.removeChild(oldImg);
  }

  const img = document.createElement('img');
  img.id = 'hiddenImage';
  img.origin = 'anonymous';
  img.src = URL.createObjectURL(selectedFile);
  img.style = "position:absolute; top: -9999px; left: -9999px;";
  img.onload = function() {
    const ctx = getCanvasContext();
    ctx.canvas.width = this.naturalWidth;
    ctx.canvas.height = this.naturalHeight;

    setDefaultHex(ctx);

		redraw();
  };

  document.body.appendChild(img);
}

function copyImageToCanvas(ctx) {
  resetCtx(ctx);
  ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
  ctx.drawImage(getImage(), 0, 0);
}

function setDefaultHex(ctx) {
  const lengthFromWidth = ctx.canvas.width / SQRT3;
  const lengthFromHeight = ctx.canvas.height / 2;
  const edge = Math.min(lengthFromWidth, lengthFromHeight);

  const xOffset = ctx.canvas.width / 2;
  const yOffset = ctx.canvas.height / 2;

  setEdgeLength(edge);
  setXOffset(xOffset);
  setYOffset(yOffset);
}

function drawHexOutline(ctx) {
  const xOffset = getXOffset();
  const yOffset = getYOffset();
  const edge = getEdgeLength();
  const halfHexWidth = calcHexWidth(edge) / 2;
  const halfHexHeight = calcHexHeight(edge) / 2;
  const quarterHexHeight = halfHexHeight / 2;

  resetCtx(ctx);
  ctx.beginPath();
	ctx.moveTo(xOffset - halfHexWidth, yOffset - quarterHexHeight);
	ctx.lineTo(xOffset - halfHexWidth, yOffset + quarterHexHeight);
	ctx.lineTo(xOffset, yOffset + halfHexHeight);
	ctx.lineTo(xOffset + halfHexWidth, yOffset + quarterHexHeight);
	ctx.lineTo(xOffset + halfHexWidth, yOffset - quarterHexHeight);
	ctx.lineTo(xOffset, yOffset - halfHexHeight);
	ctx.closePath();
	ctx.stroke();
}

function cropHex(ctx) {
  const edge = getEdgeLength();
  const hexCentreX = getXOffset();
  const hexCentreY = getYOffset();

  const hexWidth = calcHexWidth(edge);
  const hexHeight = calcHexHeight(edge);

  const hexTop = hexCentreY - hexHeight / 2;
  const hexBottom = hexCentreY + hexHeight / 2; 
	const hexRight = hexCentreX + hexWidth / 2;
  const hexLeft = hexCentreX - hexWidth/2;

	resetCtx(ctx);
  ctx.globalCompositeOperation = 'destination-out';

  const clipTop = Math.max(hexTop-1, 0);
  const clipBottom = Math.min(hexBottom+1, ctx.canvas.height);
  const clipHeight = clipBottom - clipTop;
  const clipLeft = Math.max(hexLeft-1, 0);
  const clipRight = Math.min(hexRight+1, ctx.canvas.width);
  const clipWidth = clipRight - clipLeft;

  if (hexTop > 0) {
    ctx.fillRect(0, 0, ctx.canvas.width, hexTop);
  }
  if (hexBottom < ctx.canvas.height) {
    ctx.fillRect(0, hexBottom, ctx.canvas.width, ctx.canvas.height - hexBottom);
  }
  if (hexLeft > 0) {
    ctx.fillRect(0, clipTop, hexLeft, clipHeight);
  }
  if (hexRight < ctx.canvas.width) {
    ctx.fillRect(hexRight, clipTop, ctx.canvas.width - hexRight, clipHeight);
  }

  ctx.beginPath();
  ctx.moveTo(clipLeft, clipTop);
	ctx.lineTo(clipLeft, hexTop + edge * 0.5 + 1);
	ctx.lineTo(hexLeft, hexTop + edge * 0.5);
	ctx.lineTo(hexCentreX, hexTop);
	ctx.lineTo(hexRight, hexTop + edge * 0.5);
	ctx.lineTo(clipRight, hexTop + edge * 0.5 + 1);
  ctx.lineTo(clipRight, clipTop);
  ctx.closePath();
  ctx.fill();

  ctx.beginPath();
  ctx.moveTo(clipLeft, clipBottom);
	ctx.lineTo(clipLeft, hexBottom - edge * 0.5 - 1);
	ctx.lineTo(hexLeft, hexBottom - edge * 0.5);
	ctx.lineTo(hexCentreX, hexBottom);
	ctx.lineTo(hexRight, hexBottom - edge * 0.5);
	ctx.lineTo(clipRight, hexBottom - edge * 0.5 - 1);
  ctx.lineTo(clipRight, clipBottom);
  ctx.closePath();
  ctx.fill();
}

function resetCtx(ctx) {
  ctx.globalAlpha = 1.0;
  ctx.globalCompositeOperation = 'source-over';
  ctx.lineWidth = 3;
  ctx.strokeStyle = "#FFFFFF";
}

function handleDownload(exporter) {
  const edge = getEdgeLength();

  if (edge === 0) {
    alert('hex too small');
    return;
  }  

  const hexWidth = calcHexWidth(edge);
  const hexHeight = calcHexHeight(edge);

  const canvas = document.createElement('canvas');
  canvas.width  = hexWidth;
  canvas.height = hexHeight;
  
  const xOffset = getXOffset();
  const yOffset = getYOffset();

  const x = xOffset - hexWidth / 2;
  const y = yOffset - hexHeight / 2;
  canvas.getContext('2d')
    .drawImage(document.getElementById('output'), x, y, hexWidth, hexHeight, 0, 0, hexWidth, hexHeight);

  exporter.href = canvas.toDataURL('image/png');
}

</script>
</head>
<body>
<div><input type="file" onchange="onFileSelected(event)"></div>
<div>x offset: <input type="number" id="x" onchange="onXChanged(this.value * 1)"/></div>
<div>y offset: <input type="number" id="y" onchange="onYChanged(this.value * 1)"/></div>
<div>edge: <input type="number" id="edge" onchange="onEdgeChanged(this.value * 1)"/><div>
<div><canvas id="output" height = "0" width = "0" style="border: 2px solid blueviolet"></canvas></div>
<div><a id="export" download="hexport.png" onclick="handleDownload(this)">Export</a></div>
</body>
</html>
